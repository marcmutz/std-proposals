\documentclass[11pt]{article}

\usepackage{xcolor}
\usepackage{fullpage}
\usepackage[colorlinks, allcolors=blue]{hyperref}
\usepackage{listings}
\usepackage{parskip}
\usepackage{amssymb}

\lstdefinelanguage{diff}{
  morecomment=[f][\color{blue}]{@@},           % group identifier
  morecomment=[f][\color{red}]{-},             % deleted lines
  morecomment=[f][\color{green!50!black}]{+},  % added lines
  morecomment=[f][\color{magenta}]{---},       % diff header lines
  morecomment=[f][\color{magenta}]{+++},
}

\lstset{
  basicstyle=\footnotesize\ttfamily,
}

\newcommand{\emailaddress}{marc.mutz@kdab.com}
\newcommand{\email}{\href{mailto:\emailaddress}{\emailaddress}}

\newcommand{\wgpaper}[1]{\href{https://wg21.link/#1}{#1}}
\newcommand{\isref}[1]{\textbf{[\wgpaper{#1}]}}
\newcommand{\isnref}[2]{\textbf{[\href{https://wg21.link/#1\##2}{#1}]/#2}}

\date{}
\title{More flexible \texttt{optional::value\_or()}}
\author{Marc Mutz}

\begin{document}

\maketitle\vspace{-1cm}

\begin{tabular}{ll}
  Document \#:&P2218R0\\
  Date:       &\today\\
  Audience:   &LEWGI\\
%              &Library Group\\
  Reply-to:   &\author{Marc Mutz} \textless\email\textgreater
\end{tabular}
\begin{abstract}
  We propose to extend the \texttt{value\_or()} member function
  template in \texttt{optional} in three ways:
  \begin{enumerate}
  \item Adding a default template argument to make requesting
    default-constructed values simpler:
    \begin{lstlisting}[language=c++]
      // now                         // proposed:
      opt.value_or(Type{});          opt.value_or({});
    \end{lstlisting}
    This brings \texttt{value\_or()} in line with other functions
    (most prominently \texttt{exchange()}).
  \item Adding a new emplace-like overload:
    \begin{lstlisting}[language=c++]
      // now                         // proposed:
      opt.value_or(Type{});          opt.value_or_construct();
    \end{lstlisting}
    This optimizes \texttt{value\_or()} for types that are expensive
    to construct.
  \item Adding a lazy version of the latter:
    \begin{lstlisting}[language=c++]
      // proposed:
      opt.value_or_else([] -> Type { return {}; });
    \end{lstlisting}
    further optimizing \texttt{value\_or\_construct()} at the cost of
    more verbosity.
  \end{enumerate}
\end{abstract}

\tableofcontents

%\setcounter{section}{-1}
%\section{Change History}

\section{Motivation and Scope}

When using \texttt{optional::value\_or()}, more often than not, the
fall-back value passed is some form of default-constructed value:

\begin{lstlisting}[language=c++]
  optional<int> oi = ~~~;       // (1)
  use(oi.value_or(0));
  optional<bool> ob = ~~~;      // (2)
  use(ob.value_or(false));
  optional<string> os = ~~~;    // (3)
  use(os.value_or(nullptr));    // (a)
  use(os.value_or(""));         // (b)
  use(os.value_or({}));         // (c)
  use(os.vlue_or(string{});     // (d)
  optional<vector<string>> ov = ~~~;
  use(ov.value_or(~~~???~~~));  // (4)
\end{lstlisting}

While this works fine in case of built-in types (1, 2), it already
fails to be convenient when the payload type is a user-defined type
without literals.

\subsection{How the C++ Developer Became a Gardener}

Here's the tale of a C++ developer trying to use \texttt{value\_or()}
in the \texttt{string} case (3): The developer first tries to use
\texttt{nullptr} (a), which crashes on him at runtime due to
\isnref{char.traits.require}1 in conjunction with
\isnref{string.cons}{13}. The next try (b) succeeds, but may invoke an
unnecessary ``\texttt{strlen}'', so he's told in review to use the
\texttt{string} default constructor instead. So the developer tries
(c) which fails to compile because \texttt{\{\}} fails to deduce the
template argument of \texttt{value\_or()}, which is not defaulted, as
e.g.\ the second argument of \texttt{exchange()} is. Grumpily, the
developer caves in and repeats the type name of the
\texttt{optional}'s \texttt{value\_type} (d).

The next day, he's asked to use a \texttt{optional<vector<string>>}
(4) and decides to quit and become a gardener instead.

We propose two different, orthogonal, solutions to the problem:
\begin{itemize}
\item Default the \texttt{value\_or} template argument, so
  \texttt{value\_or(\{\})} works, and/or
\item Add an emplacement-like function \texttt{value\_or\_construct(auto\&\&...)}, so
  that \texttt{value\_or\_construct()} works.
\end{itemize}
The latter addition gives rise to:
\begin{itemize}
\item Add a lazy version, \texttt{value\_or\_else(Func\&\&)}.
\end{itemize}

\subsection{Defaulting \texttt{value\_or()}'s template argument}
\label{sec:defaulting}

With this change, we'd like to ensure that \texttt{value\_or(\{\})}
works, like \texttt{exchange(\textit{var}, \{\})} does.

We can't just default like this:

\begin{lstlisting}[language=c++]
  template <typename T>
  class optional {
  public:
      ~~~~
      template <typename U = T>
      T value_or(U&&) const;
  };
\end{lstlisting}

as that would prevent moving the argument into the return value when
\texttt{T} is cv-qualified (as in \texttt{optional<const string>}). It
follows that we need to remove cv-qualifiers. We don't need to remove
references, as \texttt{optional<T\&>} is ill-formed. If and when
optional references become supported, this needs to be rethought.

\begin{lstlisting}[language=c++]
  template <typename T>
  class optional {
  public:
      ~~~~
      template <typename U = remove_cv_t<T>>
      T value_or(U&&) const;
  };
\end{lstlisting}

This enables developers to write \texttt{value\_or(\{\})}, which is
self-explanatory, as long as you know \texttt{value\_or()} as
currently specified.

It also enables all other braced initializers, not just \texttt{\{\}},
to be passed to \texttt{value\_or()}.

\subsection{Adding emplace-like \texttt{value\_or\_construct()}}
\label{sec:emplace}

The second change was suggested to the author in very early
discussions on the LEWG(I) reflector: If \texttt{value\_or()} was a
variadic emplace-like function, then \texttt{opt.value\_or()} would
return a default-constructed value if \texttt{opt} is not engaged.

While this extension would be SC and BC\footnote{The variadic version
  could overload the existing unary version by constraining the
  variadic version to \texttt{sizeof...(Args) != 1}}, this author does
not believe that \texttt{value\_or()} is a good name for such a
function: What does \texttt{opt.value\_or()} \emph{look like}? Can a
developer that knows \texttt{value\_or()} as currently specified make
sense of this expression? This author doubts that very much. To him,
this looks like ``value or nothing''. Then what's the ``nothing''
that's being returned?  Another \texttt{optional} specialisation?

So, it seems to this author that just making \texttt{value\_or()}
emplace-like would be counter-intuitive, but at the same time such
functionality could be useful. E.g., even if \texttt{value\_or(\{\})}
was enabled (as per Section~\ref{sec:defaulting}), that call would
create a default-constructed \texttt{T} which is then moved into the
return value, instead of default-constructing the return value
directly. Adding a new function for this purpose seems the best way
forward.

Taking a cue from existing factory functions in the standard
(\texttt{Allocator::construct()}), this author ended up with
\texttt{value\_or\_construct()} as the suggested name for the variadic
function. See Section~\ref{sec:naming} for alternative names.

\subsection{Adding lazy \texttt{value\_or\_else()}}
\label{sec:value_or_else}

The third change was also suggested in the initial discussion on the
LEWG(I) mailing list. While \texttt{value\_or\_construct()} already
defers contruction of the \texttt{T} to when it is actually needed, it
still requires construction of the \emph{arguments} of
construction. For cases where even that is too much, this author
suggests to add a lazy version, \texttt{value\_or\_else()}, too:

\begin{lstlisting}[language=c++]
  optional<vector<string>> opt = ~~~;
  // this works today, with optimal efficiency, but only for lvalues:
  auto v0 = opt ? *opt : vector{"Hello"s, "world"s} ;
  // value_or constructs a full vector even when not needed:
  auto v1 = opt.value_or({"Hello"s, "World"s});
  // value_or_construct() still constructs an initializer_list<string>:
  auto v2 = opt.value_or_construct({"Hello"s, "World"s});
  // value_or_else() would construct nothing:
  auto v3 = opt.value_or_else([] { return vector{"Hello"s, "World"s}; });
\end{lstlisting}

While \texttt{value\_or\_construct()} and \texttt{value\_or\_else()}
solve the same problem, this author thinks that they have sufficient
drawbacks each to warrant adding both, to wit:

\begin{itemize}
\item\texttt{value\_or\_construct()} may be very inefficient, asking
  to construct possibly-expensive constructor arguments before we know
  they're needed. Without \texttt{value\_or\_else()}, the developer is
  required to perform a manual check (cf.~\texttt{v0} above), which
  only works for lvalues.
\item\texttt{value\_or\_else()} may be too complex and/or verbose,
  with no efficiency gains compared to \texttt{value\_or\_construct()}
  when passing cheap contructor arguments:
  \begin{lstlisting}[language=c++]
    optional<QPen> opt = ~~~;
    auto c1 = opt.value_or(Qt::NoPen); // passing an enum value is cheap
    auto c2 = opt.value_or_construct(Qt::NoPen); // ditto
    auto c3 = opt.value_or_else([]{ return Qt::NoPen; }); // needlessly verbose
  \end{lstlisting}
\end{itemize}

\section{Impact on the Standard}

Only positive. Expressions enabled by this proposal make the use of
\texttt{optional::value\_or()} easier and more consistent with the
rest of the standard library, in particular,
\texttt{std::exchange()}. At the same time, no existing code is
broken, because the status quo cannot accept braced intializers as
\texttt{value\_or()} arguments.

\section{Proposed Wording}

All wording is relative to \cite{cpp2a}:

\begin{itemize}
\item In \isref{version.syn}, add a feature macro
  \texttt{\_\_cpp\_lib\_optional\_value\_or} with the value calculated
  as usual and comment ``\texttt{// also in <optional>}''.
\item Change \isref{optional.optional} as indicated:
  \begin{lstlisting}[language=diff]
    constexpr const T&& value() const&&;
-   template<class U> constexpr T value_or(U&&) const&;
-   template<class U> constexpr T value_or(U&&) &&;
+   template<class U=remove_cv_t<T>> constexpr T value_or(U&&) const&;
+   template<class U=remove_cv_t<T>> constexpr T value_or(U&&) &&;
+   template<class... Args> constexpr T value_or_construct(Args&&... args) const&;
+   template<class... Args> constexpr T value_or_construct(Args&&... args) &&;
+   template<class U, class... Args> constexpr T value_or_construct(initializer_list<U> il, Args&&... args) const&;
+   template<class U, class... Args> constexpr T value_or_construct(initializer_list<U> il, Args&&... args) &&;
+   template<class F> constexpr T value_or_else(F&& f) const&;
+   template<class F> constexpr T value_or_else(F&& f) &&;

    // [optional.mod], modifiers
  \end{lstlisting}
\item Apply the above \texttt{remove\_cv\_t<T>} default argument also
  to the declarations of \texttt{value\_or()} just above
  \isnref{optional.observe}{17} and \isnref{optional.observe}{19}.
\item At the end of \isref{optional.observe}, add:\\
  \begin{tabular}{lll}
    \\
    \multicolumn3l{\texttt{template<class...\ Args> constexpr T value\_or\_construct(Args\&\&...\ args) const\&}}\\\\
    &\multicolumn2l{\textit{Mandates:} \texttt{is\_copy\_constructible\_v<T> \&\& is\_constructible\_v<T, Args...>} is \texttt{true}.}\\
    &\multicolumn2l{\textit{Effects:} Equivalent to:}\\
    &&\texttt{return bool(*this) ?\ **this :\ T(std::forward<Args>(args)...);}\\
    \\
    \multicolumn3l{\texttt{template<class...\ Args> constexpr T value\_or\_construct(Args\&\&...\ args) \&\&}}\\\\
    &\multicolumn2l{\textit{Mandates:} \texttt{is\_move\_constructible\_v<T> \&\& is\_constructible\_v<T, Args...>} is \texttt{true}.}\\
    &\multicolumn2l{\textit{Effects:} Equivalent to:}\\
    &&\texttt{return bool(*this) ?\ std::move(**this) :\ T(std::forward<Args>(args)...);}\\
    \\
    \multicolumn3l{\texttt{template<class U, class...\ Args>}}\\
    \multicolumn3l{\texttt{\ \ constexpr T value\_or\_construct(initializer\_list<U> il, Args\&\&...\ args) const\&}}\\\\
    &\multicolumn2l{\textit{Mandates:} \texttt{is\_copy\_constructible\_v<T> \&\&}}\\
    &&\texttt{is\_constructible\_v<T, initializer\_list<U>\&, Args...>} is \texttt{true}.\\
    &\multicolumn2l{\textit{Effects:} Equivalent to:}\\
    &&\texttt{return bool(*this) ?\ **this :\ T(il, std::forward<Args>(args)...);}\\
    \\
    \multicolumn3l{\texttt{template<class U, class...\ Args>}}\\
    \multicolumn3l{\texttt{\ \ constexpr T value\_or\_construct(initializer\_list<U> il, Args\&\&...\ args) \&\&}}\\\\
    &\multicolumn2l{\textit{Mandates:} \texttt{is\_move\_constructible\_v<T> \&\&}}\\
    &&\texttt{is\_constructible\_v<T, initializer\_list<U>\&, Args...>} is \texttt{true}.\\
    &\multicolumn2l{\textit{Effects:} Equivalent to:}\\
    &&\texttt{return bool(*this) ?\ std::move(**this) :\ T(il, std::forward<Args>(args)...);}\\
  \end{tabular}
  \begin{tabular}{lll}
    \\
    \multicolumn3l{\texttt{template<class F> constexpr T value\_or\_else(F\&\&\ f) const\&}}\\\\
    &\multicolumn2l{Let \texttt{U} be \texttt{invoke\_result\_t<F>}.}\\
    &\multicolumn2l{\textit{Mandates:} \texttt{is\_copy\_constructible\_v<T> \&\& is\_convertible\_v<U, T>} is \texttt{true}.}\\
    &\multicolumn2l{\textit{Effects:} Equivalent to:}\\
    &&\texttt{return bool(*this) ?\ **this :\ std::forward<F>(f)();}\\
    \\
    \multicolumn3l{\texttt{template<class F> constexpr T value\_or\_else(F\&\&\ f) \&\&}}\\\\
    &\multicolumn2l{Let \texttt{U} be \texttt{invoke\_result\_t<F>}.}\\
    &\multicolumn2l{\textit{Mandates:} \texttt{is\_move\_constructible\_v<T> \&\& is\_convertible\_v<U, T>} is \texttt{true}.}\\
    &\multicolumn2l{\textit{Effects:} Equivalent to:}\\
    &&\texttt{return bool(*this) ?\ std::move(**this) :\ std::forward<F>(f)();}\\
  \end{tabular}
\end{itemize}

\section{Design Decisions}

If all we wanted was to make it easier to return a default-constructed
\texttt{T}, we could just add a new function
\texttt{value\_or\_default\_initialized()}. This is not proposed,
because it does not address the consistency concern with
\texttt{exchange()}.

As mentioned in Section~\ref{sec:emplace}, just making
\texttt{value\_or()} variadic leaves a lot to be desired: while
\texttt{opt.value\_or(0xff, 0xff, 0xff)} works reasonably well for a
\texttt{optional<color>}, it doesn't really work for default
construction, which is the driver behind this proposal. So this author
does not propose to make \texttt{value\_or()} variadic, but suggests
to choose a different name for this functionality.

This author chose to make \texttt{value\_or\_else()} take just a
single invokable, not a \texttt{bind}- or \texttt{thread}-style
$N$-ary argument list. The reason was twofold: First, the
single-argument version is consistent with the
\wgpaper{P0798}-proposed \texttt{or\_else()}. Second, this author
considers the \texttt{thread} constructor and \texttt{bind} functions
to be old-fashioned APIs that predate the introduction of lambdas,
requiring use of \texttt{reference\_wrapper}, which makes such APIs
hard to use.

\subsection{Naming}
\label{sec:naming}

The \texttt{value\_or()} function is pre-existing, so the name is fixed.

For the emplacement-style function, the following names were
considered by this author:

\begin{itemize}
\item \texttt{value\_or()} — works well for $N$-ary arguments, $N>0$,
  but not ery well for $N=0$, which is the major motivation for this
  proposal in the first place.
\item \texttt{value\_or\_make()} — emplacement-style factory functions
  have traditionally been called \texttt{make\_xxx}, but those are
  free functions, not class member functions. Members, indeed, tend to
  be called \texttt{construct()} (example: \texttt{Allocator}).
\item \texttt{value\_or\_constructed()} — (using the past participle
  form of \emph{construct} instead) arguably more correct form,
  gammatically, but unknown in the case of the standard API, so not
  proposed.
\end{itemize}

For the lazy version, no other names but \texttt{value\_or\_else()}
come to mind, so no alternatives were considered.

\section{Acknowledgements}

The author would like to thank all participants of the LEWG(I)
reflector discussion that led to this proposal, esp.\ Andrzej
Krzemienski for confirming that \texttt{value\_or()}'s non-defaulted
template parameter was not a conscious omission. Barry Revzin
suggested \texttt{value\_or\_else()} and mentioned the alternative
name \texttt{value\_or\_construct()} and this author never looked
back.

\section{References}
\renewcommand{\section}[2]{}%
\begin{thebibliography}{9}
\bibitem[N4861]{cpp2a}
  Richard Smith (editor)\newline
  \emph{Working Draft: Standard for Programming Language C++}\newline
  \url{http://wg21.link/N4861}
\end{thebibliography}

\end{document}

